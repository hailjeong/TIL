# 리덕스 미들웨어(Redux-Middleware)

- API 서버를 연동할 때는 API 요청에 대한 상태도 잘 관리해야 한다. 요청이 시작되었을 때는 로딩 중임을, 요청이 성공하거나 실패했을 때는 로딩이 끝났음을 명시해야 한다. 요청이 성공하면 서버에서 받아 온 응답에 대한 상태를 관리하고, 요청이 실패하면 서버에서 반환한 에러에 대한 상태를 관리해야 한다. 리액트에서 리덕스를 사용하고 있으며 비동기 작업을 관리해야 한다면, "미들웨어"를 사용하여 효율적이고 편하게 상태 관리를 할 수 있다.

## 미들웨어
- 리덕스 미들웨어는 액션을 디스패치 했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행한다. 미들웨어는 액션과 리듀서 사이의 중간자라고 볼 수 있다.
- 리듀서가 액션을 처리하기 전에 미들웨어가 할 수 있는 작업은 여러 가지가 있다. 전달받은 액션을 단순히 콘솔에 기록하거나, 전달받은 액션 정보를 기반으로 액션을 아예 취소하거나, 다른 종류의 액션을 추가로 디스패치 할 수도 있다.
- 실제 프로젝트를 할 때 미들웨어를 직접 만들어서 사용할 일은 그리 많지 않다. 다른 개발자가 만들어 놓은 미들웨어를 사용하면 되기 때문이다. 어떻게 작동하는지 이해하기 위해서는 직접 만들어 보는 것이 가장 효과적이다. 상황에 따라 직접 만들거나 기존 미들웨어들을 커스터마이징 하여 사용할 수도 있다. 
- 미들웨어는 결국 함수를 반환하는 함수를 반환하는 함수이다. 파라미터로 받아 오는 store는 리덕스 스토어 인스턴스를, action은 디스패치된 액션을 가리킨다. next는 파라미터는 함수 형태이며, store, dispatch와 비슷한 역할을 한다. 큰 차이점이 있는데 next(action)을 호출하면 그 다음 처리해야 할 미들웨어에게 액션을 넘겨주고, 만약에 미들웨어가 없다면 리듀서에게 액션을 넘겨준다는 것이다.
- 미들웨어 내부에서 store.dispatch를 사용하면 첫 번째 미들웨어부터 다시 처리한다. 만약 미들웨어에서 next를 사용하지 않으면 액션이 리듀서에 전달되지 않는다. 액션이 무시되는 것이다.
- 미들웨어에서는 여러 종류의 작업을 처리할 수 있다. 특정 조건에 따라 액션을 무시하게 할 수도 있고, 특정 조건에 따라 액션 정보를 가로채서 변경한 후 리듀서에게 전달 할 수도 있고, 특정 액션에 기반하여 새로운 액션을 여러번 디스패치 할 수도 있다.

## redux-logger
- redux-logger는 오픈 소스에 이미 올라와 있다. 브라우저 콘솔에 나타나는 형식이 훨씬 깔끔하다. 액션 디스패이 시간도 나타나고 색상도 입혀진다. 

## 비동기 작업관리
- 비동기 작업을 처리할 때 도움을 주는 미들웨어는 다양하다. 사용할 미들웨어는 redux-thunk, redux-saga이다.
- redux-thunk: 비동기 작업을 처리할 때 가장 많이 사용하는 미들웨어이다. 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해준다.
- redux-saga: redux-thunk 다음으로 가장 많이 사용되는 비동기 작업 관련 미들웨어 라이브러리이다. 특정 액션이 디스패치되었을 때 정해진 로직에 따라 다른 액션을 디스패치 시키는 규칙을 작성해 비동기 작업을 처리할 수 있게 한다.

## redux-thunk
- 가장 기본적으로 사용하는 미들웨어이다. 리덕스의 창시자인 댄 아브라모프(Dan Abramov)가 만들었다.
- Thunk는 특정 작업을 나중에 할 수 있게 함수 형태로 감싼 것을 의미한다. 
- redux-thunk를 사용하면 thunk 함수를 만들어서 디스패치할 수 있다. 미들웨어가 함수를 전달받아 store의 dispatch와 getState를 파라미터로 넣어서 호출해 준다.
```javascript
//  주어진 파라미터에 1을 더하는 함수
cosnt addOne = x => x + 1;
addOne(1) // 결과 값: 2

// 이 연산 작업을 나중에 하도록 미루는 방식
const addOne = x => x + 1;
function addOneThunk (x) {
  const thunk = () => addOne(x);
  return thunk;
}

// 화살표 함수 표현식
const addOne = x => x + 1;
const addOneThunk = x => () => addOne(x)

const fn = addOneThunk(1);
setTimeout(() => {
  const value = fn(); // fn이 실행되는 시점에 연산
  console.log(value);
}, 1000);

// dispatch와 getState파라미터 넣기
const sampleThunk = () => (dispatch, getState) => {
  // 현재 상태를 참조할 수 있다.
  // 새 액션을 디스패치할 수도 있다.
```
```javascript
// index.js 컴포넌트
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";
import { applyMiddleware, createStore } from "redux";
import { Provider } from "react-redux";
import rootReducer from "./modules";
// import loggerMiddleware from "./lib/loggerMiddleware";
import { createLogger } from "redux-logger";
import ReduxThunk from "redux-thunk";

const logger = createLogger();
const store = createStore(rootReducer, applyMiddleware(logger, ReduxThunk));

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);

// modules/counter.js 컴포넌트

import { createAction, handleActions } from "redux-actions";

const INCREASE = "counter/INCREASE";
const DECREASE = "counter/DECREASE";

export const increase = createAction(INCREASE);
export const decrease = createAction(DECREASE);

// 1초 뒤에 increase 혹은 decrease 함수를 디스패치함
export const increaseAsync = () => (dispatch) => {
  setTimeout(() => {
    dispatch(increase());
  }, 1000);
};

export const decreaseAsync = () => (dispatch) => {
  setTimeout(() => {
    dispatch(decrease());
  }, 1000);
};

const initialState = 0; // 상태는 꼭 객체일 필요가 없다. 숫자도 작동한다.

const counter = handleActions(
  {
    [INCREASE]: (state) => state + 1,
    [DECREASE]: (state) => state - 1,
  },
  initialState
);

export default counter;


// containers/CounterContainer.js 컴포넌트
import { connect } from "react-redux";
import { increaseAsync, decreaseAsync } from "../modules/counter";
import Counter from "../components/Counter";

const CounterContainer = ({ number, increaseAsync, decreaseAsync }) => {
  return (
    <Counter
      number={number}
      onIncrease={increaseAsync}
      onDecrease={decreaseAsync}
    />
  );
};

export default connect(
  (state) => ({
    number: state.counter,
  }),
  {
    increaseAsync,
    decreaseAsync,
  }
)(CounterContainer);
```

## 웹 요청 비동기 작업 
- thunk의 속성을 활용해서 웹 요청 비동기 작업을 처리하는 방법이다. 먼저 JSONPlaceholder(https://jsonplaceholder.typicode.com)에서 제공되는 가짜 API를 사용하면 된다.
  - 포스트 읽기(:id는 1~100 사이 숫자) GET https://jsonplaceholder.typicode.com/posts/:id
  - 모든 사용자 정보 불러오기 GET https://jsonplaceholder.typicode.com/users

- API를 호출할 때는 주로 Promise 기반 웹 클라이언트인 axios를 사용한다.









